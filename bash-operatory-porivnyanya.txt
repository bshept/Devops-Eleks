7.3. Операции сравнения

сравнение целых чисел

-eq

    Rivno

    if [ "$a" -eq "$b" ]
-ne

    Ne rivno

    if [ "$a" -ne "$b" ]
-gt

    bilshe

    if [ "$a" -gt "$b" ]
-ge

    bilshe rivne

    if [ "$a" -ge "$b" ]
-lt

    menshe

    if [ "$a" -lt "$b" ]
-le

    menshe rivne

    if [ "$a" -le "$b" ]
<

    menshe    

    (("$a" < "$b"))
<=

    bilshe rivne	
    
    (("$a" <= "$b"))
>

    bilshe

    (("$a" > "$b"))
>=

    bilshe rivne

    (("$a" >= "$b"))

Porivnyanya strichok

=

    rivno

    if [ "$a" = "$b" ]
==

   rivno

    if [ "$a" == "$b" ]

    sunonim rivno =.

    [[ $a == z* ]]    # истина, если $a начинается с символа "z" (сравнение по шаблону)
    [[ $a == "z*" ]]  # истина, если $a равна z*

    [ $a == z* ]      # имеют место подстановка имен файлов и разбиение на слова
    [ "$a" == "z*" ]  # истина, если $a равна z*

    # Спасибо S.C.



!=

    ne rivno

    if [ "$a" != "$b" ]

    Этот оператор используется при поиске по шаблону внутри [[ ... ]].
<

    menshe
    меньше, в смысле величины ASCII-кодов

    if [[ "$a" < "$b" ]]

    if [ "$a" \< "$b" ]

    Обратите внимание! Символ "<" необходимо экранировать внутри [ ].
>

    больше, в смысле величины ASCII-кодов

    if [[ "$a" > "$b" ]]

    if [ "$a" \> "$b" ]

    Обратите внимание! Символ ">" необходимо экранировать внутри [ ].

    См. Пример 25-6 относительно применения этого оператора сравнения.
-z

    strichka pusta, maye nulyovy dovjunu
    строка "пустая", т.е. имеет нулевую длину
-n

    strichka ne pusta
    строка не "пустая".
    Caution 	

    Оператор -n требует, чтобы строка была заключена в кавычки внутри квадратных скобок. Как правило, проверка строк, не заключенных в кавычки, оператором ! -z, или просто указание строки без кавычек внутри квадратных скобок (см. Пример 7-6), проходит нормально, однако это небезопасная, с точки зрения отказоустойчивости, практика. Всегда заключайте проверяемую строку в кавычки. [1]

Пример 7-5. Операции сравнения

#!/bin/bash

a=4
b=5

#  Здесь переменные "a" и "b" могут быть как целыми числами, так и строками.
#  Здесь наблюдается некоторое размывание границ
#+ между целочисленными и строковыми переменными,
#+ поскольку переменные в Bash не имеют типов.

#  Bash выполняет целочисленные операции над теми переменными,
#+ которые содержат только цифры
#  Будьте внимательны!

echo

if [ "$a" -ne "$b" ]
then
  echo "$a не равно $b"
  echo "(целочисленное сравнение)"
fi

echo

if [ "$a" != "$b" ]
then
  echo "$a не равно $b."
  echo "(сравнение строк)"
  #     "4"  != "5"
  # ASCII 52 != ASCII 53
fi

# Оба варианта, "-ne" и "!=", работают правильно.

echo

exit 0

Пример 7-6. Проверка -- является ли строка пустой

#!/bin/bash
# str-test.sh: Проверка пустых строк и строк, не заключенных в кавычки,

# Используется конструкция   if [ ... ]


# Если строка не инициализирована, то она не имеет никакого определенного значения.
# Такое состояние называется "null" (пустая) (это не то же самое, что ноль).

if [ -n $string1 ]    # $string1 не была объявлена или инициализирована.
then
  echo "Строка \"string1\" не пустая."
else
  echo "Строка \"string1\" пустая."
fi
# Неверный результат.
# Выводится сообщение о том, что $string1 не пустая,
#+не смотря на то, что она не была инициализирована.


echo


# Попробуем еще раз.

if [ -n "$string1" ]  # На этот раз, переменная $string1 заключена в кавычки.
then
  echo "Строка \"string1\" не пустая."
else
  echo "Строка \"string1\" пустая."
fi      # Внутри квадратных скобок заключайте строки в кавычки!


echo


if [ $string1 ]       # Опустим оператор -n.
then
  echo "Строка \"string1\" не пустая."
else
  echo "Строка \"string1\" пустая."
fi
# Все работает прекрасно.
# Квадратные скобки -- [ ], без посторонней помощи определяют, что строка пустая.
# Тем не менее, хорошим тоном считается заключать строки в кавычки ("$string1").
#
# Как указывает Stephane Chazelas,
#    if [ $string 1 ]   один аргумент "]"
#    if [ "$string 1" ]  два аргумента, пустая "$string1" и "]"



echo



string1=initialized

if [ $string1 ]       # Опять, попробуем строку без ничего.
then
  echo "Строка \"string1\" не пустая."
else
  echo "Строка \"string1\" пустая."
fi
# И снова получим верный результат.
# И опять-таки, лучше поместить строку в кавычки ("$string1"), поскольку...


string1="a = b"

if [ $string1 ]       # И снова, попробуем строку без ничего..
then
  echo "Строка \"string1\" не пустая."
else
  echo "Строка \"string1\" пустая."
fi
# Строка без кавычек дает неверный результат!

exit 0
# Спвсибо Florian Wisser, за предупреждение.

Пример 7-7. zmost

#!/bin/bash

#Просмотр gz-файлов с помощью утилиты 'most'

NOARGS=65
NOTFOUND=66
NOTGZIP=67

if [ $# -eq 0 ] # то же, что и:  if [ -z "$1" ]
# $1 должен существовать, но может быть пустым:  zmost "" arg2 arg3
then
  echo "Порядок использования: `basename $0` filename" >&2
  # Сообщение об ошибке на stderr.
  exit $NOARGS
  # Код возврата 65 (код ошибки).
fi

filename=$1

if [ ! -f "$filename" ]   # Кавычки необходимы на тот случай, если имя файла содержит пробелы.
then
  echo "Файл $filename не найден!" >&2
  # Сообщение об ошибке на stderr.
  exit $NOTFOUND
fi

if [ ${filename##*.} != "gz" ]
# Квадратные скобки нужны для выполнения подстановки значения переменной
then
  echo "Файл $1 не является gz-файлом!"
  exit $NOTGZIP
fi

zcat $1 | most

# Используется утилита 'most' (очень похожа на 'less').
# Последние версии 'most' могут просматривать сжатые файлы.
# Можно вставить 'more' или 'less', если пожелаете.


exit $?   # Сценарий возвращает код возврата, полученный по конвейеру.
# На самом деле команда "exit $?" не является обязательной,
# так как работа скрипта завершится здесь в любом случае,

построение сложных условий проверки

-a

    логическое И (and)

    exp1 -a exp2 возвращает true, если оба выражения, и exp1, и exp2 истинны.
-o

    логическое ИЛИ (or)

    exp1 -o exp2 возвращает true, если хотябы одно из выражений, exp1 или exp2 истинно.

Они похожи на операторы Bash && и ||, употребляемые в двойных квадратных скобках.

[[ condition1 && condition2 ]]

Операторы -o и -a употребляются совместно с командой test или внутри одинарных квадратных скобок.

if [ "$exp1" -a "$exp2" ]



Чтобы увидеть эти операторы в действии, смотрите Пример 8-3 и Пример 25-11.
Примечания
[1] 	

Как указывает S.C., даже заключение строки в кавычки, при построении сложных условий проверки, может оказаться недостаточным. [ -n "$string" -o "$a" = "$b" ] в некоторых версиях Bash такая проверка может вызвать сообщение об ошибке, если строка $string пустая. Безопаснее, в смысле отказоустойчивости, было бы добавить какой-либо символ к, возможно пустой, строке: [ "x$string" != x -o "x$a" = "x$b" ] (символ "x" не учитывается).